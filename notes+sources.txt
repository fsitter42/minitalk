https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3220.pdf
https://en.wikipedia.org/wiki/C_signal_handling
https://github.com/leske42/Foundations/tree/main/UB
https://godbolt.org/

atoi max longlong overflow -> stringtolong
printf pointer

minitalk.c
client:
- overflow checken bevor atoi angewendet wird bei pid
- volatile sig_atomic_t für globale variable
( - f_acknowledge_client: if i == SIGUSR2 --> pr(". "); if SIGUSR2 pr("done");

server:
- global variable static volatile sig_atomic_t um sie im signalhandler auf 1 und 0 setzen zu können
- im signalhandler "fakesingnal = 0 abfragen um pid zu finden welche ich für postsignal brauche finde"
- postsignal() funktion anleigen alles machen was ich im signalhandler habe



/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   f_client.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fsitter <fsitter@student.42vienna.com>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 12:42:24 by fsitter           #+#    #+#             */
/*   Updated: 2025/12/20 18:07:44 by fsitter          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minitalk.h"

void	f_send_message(char *msg, int pid);
void	f_acknowledge_client(int i);
void	f_end_of_line(int pid);

volatile sig_atomic_t		g_wait;

void	f_end_of_line(int pid)
{
	size_t	i;
	

	i = 8;
	while (i > 0)
	{
		g_wait = 1;
		kill(pid, SIGUSR2);
		while (g_wait)
			pause();
		i--;
	}
}

void	f_acknowledge_client(int i)
{
	if (i == SIGUSR1)
		ft_printf(". ");
	g_wait = 0;
}

#include <stdio.h>
void	f_send_message(char *msg, int pid)
{
	size_t			i;
	unsigned int	bit;

	while (*msg)
	{
		i = 0;
		bit = (unsigned char)*msg;
		while (i < 8)
		{
			g_wait = 1;
			if ((bit << i) & (1 << 7))
				kill(pid, SIGUSR1);
			else
				kill(pid, SIGUSR2);
			i++;
			while (g_wait)
			{
				printf("HELLO\n");
				pause();
			}
		}
		msg++;
	}
	f_end_of_line(pid);
	ft_printf("Message sent!\n");
}

#include <limits.h>
#include <stdio.h>
int	main(int ac, char **av)
{
	const char *str = "hello";

	printf("%c\n", str[1]);
	printf("%c\n", *(str + 1));

	unsigned int u_result = ft_atoi(av[1]);
	int result = u_result;
	result += 1;
	if (result < 0) {
		printf("OVERFLOW\n");
	}
	printf("result: %d\n", result);
	if (ac != 3)
	{
		ft_printf("Instruction: ./filename server-PID message\n");
		exit(1);
	}
	if (ft_atoi(av[1]) <= 0 || av[1][0] == '+' || ft_atoi(av[1]) > 4194304)
		return (ft_printf("Invalid server-PID\n"), -1);
	signal(SIGUSR1, &f_acknowledge_client);
	signal(SIGUSR2, &f_acknowledge_client);
	if (kill(ft_atoi(av[1]), 0) == -1)
		return (ft_printf("No connection to server.\n"), -1);
	f_send_message(av[2], ft_atoi(av[1]));
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   f_server.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fsitter <fsitter@student.42vienna.com>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/14 12:02:14 by fsitter           #+#    #+#             */
/*   Updated: 2025/12/20 18:53:54 by fsitter          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minitalk.h"

void	f_signal_handeling(int sig, siginfo_t *info, void *content);
static void post_signal();

static volatile sig_atomic_t g_signal = 0;

void	f_signal_handeling(int sig, siginfo_t *info, void *content)
{
	static volatile sig_atomic_t last_pid = 0;

	if (sig == 600 && info == NULL)
	{
		*(pid_t*)content = last_pid;
		return;
	}
	last_pid = info->si_pid;
	g_signal = sig;
}

static void post_signal()
{
	static int				i = 0;
	static unsigned char	bit = 0;
	static unsigned char	byte = 0;
	static unsigned char	message[131072];
	pid_t client_pid;

	f_signal_handeling(600, NULL, &client_pid);
	if (g_signal == SIGUSR1)
		byte = (byte << 1) | 1;
	else
		byte = byte << 1;
	bit++;
	if (bit == 8)
	{
		message[i++] = byte;
		if (!byte)
		{
			i = 0;
			ft_printf("%s\n", message);
			kill(client_pid, SIGUSR1);
		}
		bit = 0;
		byte = 0;
	}
	kill(client_pid, SIGUSR2);
}

int	main(void)
{
	struct sigaction	chimpanzini_bananini;

	chimpanzini_bananini.sa_sigaction = &f_signal_handeling;
	chimpanzini_bananini.sa_flags = SA_SIGINFO;
	sigemptyset(&chimpanzini_bananini.sa_mask);
	ft_printf("Server PID: %i\n", getpid());
	if (sigaction(SIGUSR1, &chimpanzini_bananini, NULL) == -1)
		ft_printf("ERROR: Receiving signal 1!\n");
	if (sigaction(SIGUSR2, &chimpanzini_bananini, NULL) == -1)
		ft_printf("ERROR: Receiving signal 2!\n");
	while (1)
	{
		pause();
		post_signal();
	}
	return (0);
}
